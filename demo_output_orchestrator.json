{
  "chunks": [
    {
      "chunk_id": "e1c0ea001642_0000",
      "content": "# [1 Introduction](#introduction)\n\nDevice Modeling Language (DML) is a domain-specific programming language for developing device models to be simulated with Simics. DML has been designed to make it easy to represent the kind of things that are needed by a device model, and uses special syntactic constructs to describe common elements such as memory mapped hardware registers, connections to other Simics configuration objects, and checkpointable device state.\nDML is an object-oriented language, where each device is represented through an object, which \u2014 as members \u2014 may feature pieces of mutable state, configurable parameters and attributes, subroutines (called methods), and subobjects that may have their own members. In contrast to most general-purpose object-oriented languages, objects in DML are statically declared rather than dynamically created, and typically represent logical components of the device.\nA complete DML model specifies exactly one device model, together with:\n  * Associated register banks, and how these may be memory mapped\n  * Specifications of connections to other devices that the device expects to have access to, and thus may make use of.\n  * Specifications of connections that other devices may establish to the device, and how messages sent through those connections are handled by the device.\n  * Specification of attributes that Simics may access for the purposes of configuring the device, inspect the device operation, or to checkpoint the device state.\n  * The name and description of the device, together with other static meta-information",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)"
        ],
        "section_level": 1,
        "contains_code": false,
        "code_languages": [],
        "chunk_index": 0,
        "line_start": 3,
        "line_end": 11,
        "char_count": 1586,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0001",
      "content": "evice, together with other static meta-information\n\n# [1 Introduction](#introduction)\n\nThese are the crucial properties of device models that must be made visible to Simics, and each of these have specialized language features in order to declare them. Beyond these, DML also has a number of features to improve the expressive power of the language and simplify development; for instance, DML offers _templates_ , a powerful metaprogramming tool that allows for code reduction and reuse, as well as a means of building abstractions.\nThe DML compiler is called _Device Modeling Language Compiler_ , `dmlc`. It translates a device model description written in DML into C source code that can be compiled and loaded as a Simics module.\nThis document describes the DML language, the standard libraries, and the `dmlc` compiler, as of version 1.4 of DML. See also _Simics Model Builder User's Guide_ for an introduction to DML.",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)"
        ],
        "section_level": 1,
        "contains_code": false,
        "code_languages": [],
        "chunk_index": 1,
        "line_start": 3,
        "line_end": 16,
        "char_count": 922,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0002",
      "content": " Builder User's Guide_ for an introduction to DML.\n\n# [1 Introduction](#introduction)\n\nThe following is an example of a small DML model defining a very simple device. This lacks many details that would appear in a real device.\n\n```text\ndml 1.4;\ndevice contraption;\nconnect wakeup {\n  interface signal;\n}\nbank config_registers {\n  register cfg1 size 4 @ 0x0000 {\n    field status @ [7:6] is (read, write) {\n      method read() -> (uint64) {\n        local uint2 ret;\n        ret[0] = enable.val;\n        ret[1] = coefficient[1] & 1;\n        return ret;\n      }\n    }\n    field enable @ [8] is (read_unimpl, write) {\n      method write(uint64 val) {\n        if (this.val == 0 and val == 1) {\n          wakeup.signal.signal_raise();\n        } else if (this.val == 1 and val == 0) {\n          wakeup.signal.signal_lower();\n        }\n      }\n    }\n  }\n  register coefficient[i < 4] size 8 @ 0x0008 + i * 8 is (read, write) {}\n}\n\n\n```\n",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)"
        ],
        "section_level": 1,
        "contains_code": true,
        "code_languages": [
          "text"
        ],
        "chunk_index": 2,
        "line_start": 3,
        "line_end": 49,
        "char_count": 928,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0003",
      "content": "# [1 Introduction](#introduction)\n\n* The `device contraption;` statement declares the name of the device.\n  * The `connect wakeup` part declares that the device can be configured to communicate with other devices using the `signal` interface.\n  * The `bank config_registers` part declares a bank of memory-mapped registers. If the bank is mapped into a memory space, then software can use this to control the device through reads and writes.\n  * The bank contains _registers_ , which declare sizes and offsets statically. When the bank is accessed with a memory transaction, it will check which register the transaction hits, and redirect as a read or write operation in that register.\n  * The `cfg1` register is further subdivided into _fields_ , one covering bits 7 and 6 and one covering bit 8.\n  * The bank, registers and fields form a _hierarchy_ of objects, which provides a simple mechanism for encapsulation. Each object is a separate namespace, and the object hierarchy naturally forms a nested scope.\n  * The `is` statement specifies a number of _templates_ to be instantiated for the associated object. The `read` and `write` templates prepare code for the targeted field which makes it software readable and writable, as well as methods `read` and `write` that may be overridden in order to customize the behavior upon a software read or write. In contrast, the `read_unimpl` template prepares code that causes the field to log a warning if read by software.\n  * Methods in DML are much like functions in C. The statements of the method body are similar to C with some differences; e.g., integers support bitslicing using the syntax `value[a:b]`. Methods also have a place in the object hierarchy, and can freely access the object's state and connections.\n  * `coefficient` is an _array_ of register objects, marked by the use of `[i < _size_]`. The object specification provided to an object array is used for each element of the array, and the`i` parameter can be used for element-specific logic. In this case, `i` is used to assign each register of the array to different address offsets.",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)"
        ],
        "section_level": 1,
        "contains_code": false,
        "code_languages": [],
        "chunk_index": 3,
        "line_start": 3,
        "line_end": 58,
        "char_count": 2103,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0004",
      "content": "egister of the array to different address offsets.\n\n# [1 Introduction](#introduction)\n\nThe [above example](#source-file-example) demonstrates how a DML device is built from a hierarchy of objects, such as banks and register. The hierarchy is composed of the following object types:\n  * Each DML model defines a single [`device` object](language.html#the-device), which can be instantiated as a configuration object in Simics. All objects declared at the top level are members of the device object.\n  * An [`attribute` object](language.html#attributes) creates a Simics configuration attribute of the device. An attribute usually has one of three uses:\n\n```text\n* Configuring some aspect of the device on instantiation\n* Saving and restoring simulation state for checkpointing. For simple types this is easier to achieve with [saved variables](language.html#saved-variables), but attributes can be necessary to serialize more complex types.\n* Exposing a back-door into the model for inspection or debugging, called a _pseudo_ attribute\n```\n",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)"
        ],
        "section_level": 1,
        "contains_code": true,
        "code_languages": [
          "text"
        ],
        "chunk_index": 4,
        "line_start": 3,
        "line_end": 67,
        "char_count": 1039,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0005",
      "content": "# [1 Introduction](#introduction)\n\n* A [`bank` object](language.html#register-banks) makes sets of registers accessible by placing them in an _address space_. Register banks can be individually mapped into Simics memory spaces.\n  * A [`register` object](language.html#registers) holds an integer value, and is generally used to model a hardware register, used for communication via memory-mapped I/O. A register is between 1 and 8 bytes wide. Registers divide the address space of a bank into discrete elements with non-overlapping addresses.\n  * [`field` objects](language.html#fields) constitute a further subdivision of `register` objects, on the bit level. Each field can be accessed separately, both for reading and for writing. The fields of a register may not overlap.\n  * [`group`](language.html#groups) is the general-purpose object type, without any special properties or restrictions. Groups are mainly used as container objects \u2014 in particular, to define logical groups of registers within a bank. The generic nature of groups also makes them useful as a tool for creating abstractions.\n  * A [`connect` object](language.html#connects) holds a reference to a Simics configuration object. (Typically, the connected object is expected to implement some particular Simics-interface.) An attribute with the same name is added to the `device`; thus, a `connect` is similar to a simple `attribute` object. Usually, initialization is done when the device is configured, e.g. when loading a checkpoint or instantiating a component.\n  * An [`interface` object](language.html#interfaces) may be declared within a `connect` object, and specifies a Simics interface assumed to be implemented by the connected object. In many cases, the name of the interface is sufficient, and the body of the object can be left empty.\n  * A [`port` object](language.html#ports) represents a point where an outside device can connect to this device. This is done by creating a separate Simics object; if a device has a declaration `port irq` and the device is instantiated as `dev` in Simics, then the port object is named `dev.port.irq`.\n  * An [`implement` object](language.html#implements) specifies an implementation of a _Simics interface_ that the device implements. An `implement` object is normally declared inside a `port`, and defines the interfaces registered on the corresponding Simics configuration object; however, `implement` can also be declared on the top-level `device` object or in a `bank` object.\nThe methods defined within the `implement` object must correspond to the functions of the Simics interface.\nA device can implement the same interface several times, by creating multiple `port` objects with `implement` objects of the same name.\n  * An [`event` object](language.html#events) is an encapsulation of a Simics event, that can be posted on a time queue (CPU or clock).\n  * A [`subdevice` object](language.html#subdevices) represents a subsystem of a device, which can contain its own ports, banks, and attributes.",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)"
        ],
        "section_level": 1,
        "contains_code": false,
        "code_languages": [],
        "chunk_index": 5,
        "line_start": 3,
        "line_end": 79,
        "char_count": 3026,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0006",
      "content": " can contain its own ports, banks, and attributes.\n\n# [1 Introduction](#introduction)\n\n[Methods](language.html#methods-detailed) are the DML representation of subroutines. They may be declared as members of any object or template. Any method may have multiple input parameters, specified similarly as C functions. Unlike C, DML methods may have multiple return values, and the lack of a return value is indicated through an empty list of return values rather than `void`. The following demonstrates a method declaration with no input parameters or return values:\n\n```text\nmethod noop() -> () {\n  return;\n}\n\n\n```\n\nAlternatively:\n\n```text\nmethod noop() {\n  return;\n}\n\n\n```\n\nThe following demonstrates a method declaration with multiple input and parameters and return values:\n\n```text\nmethod div_mod(uint64 dividend, uint64 divisor)\n  -> (uint64, uint64) {\n  local uint64 quot = dividend / divisor;\n  local uint64 rem = dividend % divisor;\n  return (quot, rem);\n}\n\n\n```\n",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)"
        ],
        "section_level": 1,
        "contains_code": true,
        "code_languages": [
          "text"
        ],
        "chunk_index": 6,
        "line_start": 3,
        "line_end": 109,
        "char_count": 968,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0007",
      "content": "# [1 Introduction](#introduction)\n\nThis also demonstrates how local, stack-allocated variables within methods may be declared; through the `local` keyword. This is analogous to C\u2019s `auto` variable kind, but unlike C, the keyword must be explicitly given. DML features two other variable kinds: [`session`](language.html#session-variables) and [`saved`](language.html#session-variables). Unlike `local` variables, `session` and `saved` variables may also be declared as members of any object within the DML model, and can only be initialized with constant expressions.\n`session` variables represent statically allocated variables, and act as the DML equivalent of static variables in C. The value of a `session` variable is preserved for the duration of the current simulation session, but are not automatically serialized and restored during checkpointing. This means that it is the model developer\u2019s responsibility to manually serialize and restore any `session` variables upon saving or restoring a checkpoint. `saved` variables behave exactly like `session` variables, except the value of `saved` variables are serialized and restored during checkpointing. Because of this, a `saved` variable must be of a type that DML knows how to serialize. Most built-in non-pointer C types are serializable, and any `struct` that consists solely of serializable types are also considered serializable. Pointer types are never considered serializable.\nMethods have access to a basic exception-handling mechanism through the [`throw` statement](language.html#throw-statements), which raises an exception without associated data. Such exceptions may be caught via the [`try { ... } except { ... }` statement](language.html#try-statements). If a method may throw an uncaught exception, that method must be declared `throws`; for example:",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)"
        ],
        "section_level": 1,
        "contains_code": false,
        "code_languages": [],
        "chunk_index": 7,
        "line_start": 3,
        "line_end": 112,
        "char_count": 1824,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0008",
      "content": "hat method must be declared `throws`; for example:\n\n# [1 Introduction](#introduction)\n\n\n```text\nmethod demand(bool condition) throws {\n  if (!condition) {\n    throw;\n  }\n}\n\n\n```\n\nA [_template_](language.html#templates) specifies a block of code that may be inserted into objects. Templates may only be declared at the top-level, which is done as follows:\n\n```text\ntemplate _name_ { _body_ }\n\n\n```\n\nwhere _name_ is the name of the template, and _body_ is a set of object statements. A template may be instantiated through the `is` object statement, which can be used within either objects, or within templates. For example:\n\n```text\nbank regs {\n  // Instantiate a single template: templateA\n  is templateA;\n  // Instantiate multiple templates: templateB and templateC\n  is (templateB, templateC);\n  register reg size 1 @0x0;\n}\n\n\n```\n",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)"
        ],
        "section_level": 1,
        "contains_code": true,
        "code_languages": [
          "text"
        ],
        "chunk_index": 8,
        "line_start": 3,
        "line_end": 140,
        "char_count": 832,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0009",
      "content": "# [1 Introduction](#introduction)\n\nThe `is` object statement causes the body of the specified templates to be injected into the object or template in which the statement was used.\n`is` can also be used in a more idiomatic fashion together with the declaration of an object or template as follows:\n\n```text\n// Instantiate templates templateA, templateB, and templateC\nbank regs is (templateA, templateB, templateC) {\n  register reg size 1 @0x0;\n}\n\n\n```\n",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)"
        ],
        "section_level": 1,
        "contains_code": true,
        "code_languages": [
          "text"
        ],
        "chunk_index": 9,
        "line_start": 3,
        "line_end": 150,
        "char_count": 452,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0010",
      "content": "# [1 Introduction](#introduction)\n\nA language feature closely related to templates are [_parameters_](language.html#parameters). A parameter can be thought of as an _expression macro_ that is a member of a particular object or template. Parameters may optionally be declared without an accompanying definition \u2014 which will result in a compile-time error if not overridden \u2014 or with a _default_ , overridable definition. Parameters declared this way can be overridden by any later declaration of the same parameter. This can be leveraged by templates in order to declare a parameter that the template may make use of, while requiring any instance of the template to provide a definition for the parameter (or allow instances to override the default definition of that parameter).\nParameters are declared as follows:\n  * Abstract, without definition:```\nparam _name_;\n\n```text\n  * With overridable definition:```\nparam _name_ default _expression_;\n\n\n```\n",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)"
        ],
        "section_level": 1,
        "contains_code": true,
        "code_languages": [
          "text"
        ],
        "chunk_index": 10,
        "line_start": 3,
        "line_end": 162,
        "char_count": 952,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0011",
      "content": "```\n\n\n# [1 Introduction](#introduction)\n\n* With unoverridable definition:```\nparam _name_ = _expression_;\n```\nMuch of the DML infrastructure, as well as DML\u2019s built-in features, rely heavily on templates. Due to the importance of templates, DML has a number of features to generically manipulate and reference template instances, both at compile time and at run time. These are [_templates as types_](language.html#templates-as-types), [`each`-`in` expressions](language.html#each-in-expressions), and [`in each` declarations](language.html#in-each-declarations).\n[Device Modeling Language 1.4 Reference Manual](index.html) [2 The DML compiler](running-dmlc.html)",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)"
        ],
        "section_level": 1,
        "contains_code": false,
        "code_languages": [],
        "chunk_index": 11,
        "line_start": 3,
        "line_end": 171,
        "char_count": 663,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0012",
      "content": "ndex.html) [2 The DML compiler](running-dmlc.html)\n\n## [1.1 Source File Example](#source-file-example)\n\nThe following is an example of a small DML model defining a very simple device. This lacks many details that would appear in a real device.\n\n```text\ndml 1.4;\ndevice contraption;\nconnect wakeup {\n  interface signal;\n}\nbank config_registers {\n  register cfg1 size 4 @ 0x0000 {\n    field status @ [7:6] is (read, write) {\n      method read() -> (uint64) {\n        local uint2 ret;\n        ret[0] = enable.val;\n        ret[1] = coefficient[1] & 1;\n        return ret;\n      }\n    }\n    field enable @ [8] is (read_unimpl, write) {\n      method write(uint64 val) {\n        if (this.val == 0 and val == 1) {\n          wakeup.signal.signal_raise();\n        } else if (this.val == 1 and val == 0) {\n          wakeup.signal.signal_lower();\n        }\n      }\n    }\n  }\n  register coefficient[i < 4] size 8 @ 0x0008 + i * 8 is (read, write) {}\n}\n\n\n```\n",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)",
          "[1.1 Source File Example](#source-file-example)"
        ],
        "section_level": 2,
        "contains_code": true,
        "code_languages": [
          "text"
        ],
        "chunk_index": 12,
        "line_start": 17,
        "line_end": 49,
        "char_count": 945,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0013",
      "content": "## [1.1 Source File Example](#source-file-example)\n\n* The `device contraption;` statement declares the name of the device.\n  * The `connect wakeup` part declares that the device can be configured to communicate with other devices using the `signal` interface.\n  * The `bank config_registers` part declares a bank of memory-mapped registers. If the bank is mapped into a memory space, then software can use this to control the device through reads and writes.\n  * The bank contains _registers_ , which declare sizes and offsets statically. When the bank is accessed with a memory transaction, it will check which register the transaction hits, and redirect as a read or write operation in that register.\n  * The `cfg1` register is further subdivided into _fields_ , one covering bits 7 and 6 and one covering bit 8.\n  * The bank, registers and fields form a _hierarchy_ of objects, which provides a simple mechanism for encapsulation. Each object is a separate namespace, and the object hierarchy naturally forms a nested scope.\n  * The `is` statement specifies a number of _templates_ to be instantiated for the associated object. The `read` and `write` templates prepare code for the targeted field which makes it software readable and writable, as well as methods `read` and `write` that may be overridden in order to customize the behavior upon a software read or write. In contrast, the `read_unimpl` template prepares code that causes the field to log a warning if read by software.\n  * Methods in DML are much like functions in C. The statements of the method body are similar to C with some differences; e.g., integers support bitslicing using the syntax `value[a:b]`. Methods also have a place in the object hierarchy, and can freely access the object's state and connections.\n  * `coefficient` is an _array_ of register objects, marked by the use of `[i < _size_]`. The object specification provided to an object array is used for each element of the array, and the`i` parameter can be used for element-specific logic. In this case, `i` is used to assign each register of the array to different address offsets.",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)",
          "[1.1 Source File Example](#source-file-example)"
        ],
        "section_level": 2,
        "contains_code": false,
        "code_languages": [],
        "chunk_index": 13,
        "line_start": 17,
        "line_end": 58,
        "char_count": 2120,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0014",
      "content": "egister of the array to different address offsets.\n\n## [1.2 Object types](#object-types)\n\nThe [above example](#source-file-example) demonstrates how a DML device is built from a hierarchy of objects, such as banks and register. The hierarchy is composed of the following object types:\n  * Each DML model defines a single [`device` object](language.html#the-device), which can be instantiated as a configuration object in Simics. All objects declared at the top level are members of the device object.\n  * An [`attribute` object](language.html#attributes) creates a Simics configuration attribute of the device. An attribute usually has one of three uses:\n\n```text\n* Configuring some aspect of the device on instantiation\n* Saving and restoring simulation state for checkpointing. For simple types this is easier to achieve with [saved variables](language.html#saved-variables), but attributes can be necessary to serialize more complex types.\n* Exposing a back-door into the model for inspection or debugging, called a _pseudo_ attribute\n```\n",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)",
          "[1.2 Object types](#object-types)"
        ],
        "section_level": 2,
        "contains_code": true,
        "code_languages": [
          "text"
        ],
        "chunk_index": 14,
        "line_start": 61,
        "line_end": 67,
        "char_count": 1042,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0015",
      "content": "## [1.2 Object types](#object-types)\n\n* A [`bank` object](language.html#register-banks) makes sets of registers accessible by placing them in an _address space_. Register banks can be individually mapped into Simics memory spaces.\n  * A [`register` object](language.html#registers) holds an integer value, and is generally used to model a hardware register, used for communication via memory-mapped I/O. A register is between 1 and 8 bytes wide. Registers divide the address space of a bank into discrete elements with non-overlapping addresses.\n  * [`field` objects](language.html#fields) constitute a further subdivision of `register` objects, on the bit level. Each field can be accessed separately, both for reading and for writing. The fields of a register may not overlap.\n  * [`group`](language.html#groups) is the general-purpose object type, without any special properties or restrictions. Groups are mainly used as container objects \u2014 in particular, to define logical groups of registers within a bank. The generic nature of groups also makes them useful as a tool for creating abstractions.\n  * A [`connect` object](language.html#connects) holds a reference to a Simics configuration object. (Typically, the connected object is expected to implement some particular Simics-interface.) An attribute with the same name is added to the `device`; thus, a `connect` is similar to a simple `attribute` object. Usually, initialization is done when the device is configured, e.g. when loading a checkpoint or instantiating a component.\n  * An [`interface` object](language.html#interfaces) may be declared within a `connect` object, and specifies a Simics interface assumed to be implemented by the connected object. In many cases, the name of the interface is sufficient, and the body of the object can be left empty.\n  * A [`port` object](language.html#ports) represents a point where an outside device can connect to this device. This is done by creating a separate Simics object; if a device has a declaration `port irq` and the device is instantiated as `dev` in Simics, then the port object is named `dev.port.irq`.\n  * An [`implement` object](language.html#implements) specifies an implementation of a _Simics interface_ that the device implements. An `implement` object is normally declared inside a `port`, and defines the interfaces registered on the corresponding Simics configuration object; however, `implement` can also be declared on the top-level `device` object or in a `bank` object.\nThe methods defined within the `implement` object must correspond to the functions of the Simics interface.\nA device can implement the same interface several times, by creating multiple `port` objects with `implement` objects of the same name.\n  * An [`event` object](language.html#events) is an encapsulation of a Simics event, that can be posted on a time queue (CPU or clock).\n  * A [`subdevice` object](language.html#subdevices) represents a subsystem of a device, which can contain its own ports, banks, and attributes.",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)",
          "[1.2 Object types](#object-types)"
        ],
        "section_level": 2,
        "contains_code": false,
        "code_languages": [],
        "chunk_index": 15,
        "line_start": 61,
        "line_end": 79,
        "char_count": 3029,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0016",
      "content": " can contain its own ports, banks, and attributes.\n\n## [1.3 Methods and Mutable Variables](#methods-and-mutable-variables)\n\n[Methods](language.html#methods-detailed) are the DML representation of subroutines. They may be declared as members of any object or template. Any method may have multiple input parameters, specified similarly as C functions. Unlike C, DML methods may have multiple return values, and the lack of a return value is indicated through an empty list of return values rather than `void`. The following demonstrates a method declaration with no input parameters or return values:\n\n```text\nmethod noop() -> () {\n  return;\n}\n\n\n```\n\nAlternatively:\n\n```text\nmethod noop() {\n  return;\n}\n\n\n```\n\nThe following demonstrates a method declaration with multiple input and parameters and return values:\n\n```text\nmethod div_mod(uint64 dividend, uint64 divisor)\n  -> (uint64, uint64) {\n  local uint64 quot = dividend / divisor;\n  local uint64 rem = dividend % divisor;\n  return (quot, rem);\n}\n\n\n```\n",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)",
          "[1.3 Methods and Mutable Variables](#methods-and-mutable-variables)"
        ],
        "section_level": 2,
        "contains_code": true,
        "code_languages": [
          "text"
        ],
        "chunk_index": 16,
        "line_start": 82,
        "line_end": 109,
        "char_count": 1005,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0017",
      "content": "## [1.3 Methods and Mutable Variables](#methods-and-mutable-variables)\n\nThis also demonstrates how local, stack-allocated variables within methods may be declared; through the `local` keyword. This is analogous to C\u2019s `auto` variable kind, but unlike C, the keyword must be explicitly given. DML features two other variable kinds: [`session`](language.html#session-variables) and [`saved`](language.html#session-variables). Unlike `local` variables, `session` and `saved` variables may also be declared as members of any object within the DML model, and can only be initialized with constant expressions.\n`session` variables represent statically allocated variables, and act as the DML equivalent of static variables in C. The value of a `session` variable is preserved for the duration of the current simulation session, but are not automatically serialized and restored during checkpointing. This means that it is the model developer\u2019s responsibility to manually serialize and restore any `session` variables upon saving or restoring a checkpoint. `saved` variables behave exactly like `session` variables, except the value of `saved` variables are serialized and restored during checkpointing. Because of this, a `saved` variable must be of a type that DML knows how to serialize. Most built-in non-pointer C types are serializable, and any `struct` that consists solely of serializable types are also considered serializable. Pointer types are never considered serializable.\nMethods have access to a basic exception-handling mechanism through the [`throw` statement](language.html#throw-statements), which raises an exception without associated data. Such exceptions may be caught via the [`try { ... } except { ... }` statement](language.html#try-statements). If a method may throw an uncaught exception, that method must be declared `throws`; for example:",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)",
          "[1.3 Methods and Mutable Variables](#methods-and-mutable-variables)"
        ],
        "section_level": 2,
        "contains_code": false,
        "code_languages": [],
        "chunk_index": 17,
        "line_start": 82,
        "line_end": 112,
        "char_count": 1861,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0018",
      "content": "hat method must be declared `throws`; for example:\n\n## [1.3 Methods and Mutable Variables](#methods-and-mutable-variables)\n\n\n```text\nmethod demand(bool condition) throws {\n  if (!condition) {\n    throw;\n  }\n}\n\n\n```\n",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)",
          "[1.3 Methods and Mutable Variables](#methods-and-mutable-variables)"
        ],
        "section_level": 2,
        "contains_code": true,
        "code_languages": [
          "text"
        ],
        "chunk_index": 18,
        "line_start": 82,
        "line_end": 121,
        "char_count": 215,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0019",
      "content": "## [1.4 Templates and Parameters](#templates-and-parameters)\n\nA [_template_](language.html#templates) specifies a block of code that may be inserted into objects. Templates may only be declared at the top-level, which is done as follows:\n\n```text\ntemplate _name_ { _body_ }\n\n\n```\n\nwhere _name_ is the name of the template, and _body_ is a set of object statements. A template may be instantiated through the `is` object statement, which can be used within either objects, or within templates. For example:\n\n```text\nbank regs {\n  // Instantiate a single template: templateA\n  is templateA;\n  // Instantiate multiple templates: templateB and templateC\n  is (templateB, templateC);\n  register reg size 1 @0x0;\n}\n\n\n```\n\nThe `is` object statement causes the body of the specified templates to be injected into the object or template in which the statement was used.\n`is` can also be used in a more idiomatic fashion together with the declaration of an object or template as follows:",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)",
          "[1.4 Templates and Parameters](#templates-and-parameters)"
        ],
        "section_level": 2,
        "contains_code": true,
        "code_languages": [
          "text"
        ],
        "chunk_index": 19,
        "line_start": 122,
        "line_end": 142,
        "char_count": 977,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0020",
      "content": "e declaration of an object or template as follows:\n\n## [1.4 Templates and Parameters](#templates-and-parameters)\n\n\n```text\n// Instantiate templates templateA, templateB, and templateC\nbank regs is (templateA, templateB, templateC) {\n  register reg size 1 @0x0;\n}\n\n\n```\n\nA language feature closely related to templates are [_parameters_](language.html#parameters). A parameter can be thought of as an _expression macro_ that is a member of a particular object or template. Parameters may optionally be declared without an accompanying definition \u2014 which will result in a compile-time error if not overridden \u2014 or with a _default_ , overridable definition. Parameters declared this way can be overridden by any later declaration of the same parameter. This can be leveraged by templates in order to declare a parameter that the template may make use of, while requiring any instance of the template to provide a definition for the parameter (or allow instances to override the default definition of that parameter).\nParameters are declared as follows:\n  * Abstract, without definition:```\nparam _name_;",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)",
          "[1.4 Templates and Parameters](#templates-and-parameters)"
        ],
        "section_level": 2,
        "contains_code": true,
        "code_languages": [
          "text"
        ],
        "chunk_index": 20,
        "line_start": 122,
        "line_end": 154,
        "char_count": 1100,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    },
    {
      "chunk_id": "e1c0ea001642_0021",
      "content": "## [1.4 Templates and Parameters](#templates-and-parameters)\n\n\n```text\n  * With overridable definition:```\nparam _name_ default _expression_;\n\n\n```\n\n* With unoverridable definition:```\nparam _name_ = _expression_;\n```\nMuch of the DML infrastructure, as well as DML\u2019s built-in features, rely heavily on templates. Due to the importance of templates, DML has a number of features to generically manipulate and reference template instances, both at compile time and at run time. These are [_templates as types_](language.html#templates-as-types), [`each`-`in` expressions](language.html#each-in-expressions), and [`in each` declarations](language.html#in-each-declarations).\n[Device Modeling Language 1.4 Reference Manual](index.html) [2 The DML compiler](running-dmlc.html)",
      "metadata": {
        "source_file": "pipeline_output/downloaded_pages/simics_docs_dml-1.4-reference-manual_introduction.md",
        "heading_hierarchy": [
          "[1 Introduction](#introduction)",
          "[1.4 Templates and Parameters](#templates-and-parameters)"
        ],
        "section_level": 2,
        "contains_code": true,
        "code_languages": [
          "text"
        ],
        "chunk_index": 21,
        "line_start": 122,
        "line_end": 171,
        "char_count": 771,
        "token_count": null
      },
      "summary": null,
      "embedding": null
    }
  ],
  "statistics": {
    "total_documents": 0,
    "total_chunks": 0,
    "total_code_blocks": 0,
    "average_chunk_size": 0.0,
    "processing_time_seconds": 0.0,
    "failed_documents": 0
  }
}